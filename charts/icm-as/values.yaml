# Default values for icm-as.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

# define the number of replicas beeing deployed (int, > 0, default=1)
replicaCount: 1

# define the update strategy (possible values: Recreate, RollingUpdate; default=RollingUpdate)
updateStrategy: RollingUpdate

# define where the application shall run on
nodeSelector: {}
#  agentpool: <your agentpool>

# define custom annotations for deployment and pods:
deploymentAnnotations: {}
#  myAnnotation: true
podAnnotations: {}
#  myAnnotation: true

# define podbinding if required
podBinding:
  enabled: false
  binding: <name-of-the-binding>

# define custom labels for deployment and pods:
deploymentLabels: {}
podLabels: {}

image:
  pullPolicy: IfNotPresent
  # 'appServer' container provides the application / service endpoint
  repository: "intershophub/icm-as"
  # tag: "11.1.3"

## define a secret for a container registry
dockerSecret:
  enabled: false
  name: "dockerhub"
  username: "<your registry username>"
  password: "<your registry password>"

## Optionally specify an array of imagePullSecrets. Secrets must be manually created in the namespace
## or by the above dockerSecrets section.
## https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
## Intershop: These secrets also last for customization images
imagePullSecrets:
  - "dockerhub"

# list of customization images each following the structure:
#  <name>:
#    repository: <repo incl. tag>
#    secret: <optional pull secret>
#    pullPolicy: <pullPolicy, default=IfNotPresent>
customizations: {}
# e.g.:
#  responsive:
#    repository: responsive-repo:0.8.15
#    pullPolicy: IfNotPresent
#  my-project:
#    repository: my-project-repo:0.0.7
#  custom-adapter:
#    repository: custom-adapter-repo:47.11.0
#    pullPolicy: IfNotPresent

## Control options regarding the java-vm running the ICM-AS
jvm:
  debug:
    # enable/disable to java-vm-debugging
    enabled: false
  # define options / parameters to be used to start the jvm
  options: "-XX:NewRatio=8 -XX:MaxRAMPercentage=80 -XX:InitialRAMPercentage=80"
  # define additional options / parameters to be used to start the jvm (will be appended to options)
  additionalOptions:

# configuration related to New Relic
newrelic:
  # enable or disable the New Relic Java agent to monitor the icm-as JVM
  # https://docs.newrelic.com/docs/kubernetes-pixie/kubernetes-integration/advanced-configuration/link-apm-applications-kubernetes/
  enabled: false
  #   application name (~= environment name): calculated from operationalContext section, set to override
  # app_name: "icm"
  license_key: "secret"
  metrics:
    # fine grade possibilitity to disable metrics for cost reduction
    enabled: true
  apm:
    # fine grade possibilitity to disable apm for cost reduction
    enabled: true

nameOverride: ""

fullnameOverride: ""

# Set a custom server name. Defaults to 'appserver'
# serverName: <customServerName>

# operational context (~= environment) this icm is running in
operationalContext:
  #   id of the customer e.g. xxxxx
  # customerId: <customerId>
  # type of the environment (one of {int,uat,prd}, default=prd)
  environmentType: prd
  # name of the environment (environment-type + some sort of id, e.g. int-01, default=<environmentType>)
  environmentName: prd
  # type of the application (default=icm)
  applicationType: icm

# provide custom cluster config from "icm-as.fullname"-system-conf-cluster configmap
provideCustomConfig:
  {}

  # logback-main:
  #   mountPath: /intershop/system-conf/cluster/
  #   fileName: logback-main.xml
  # urlrewriterules:
  #   mountPath: /intershop/system-conf/cluster/
  #   fileName: urlrewriterules.xml

serviceAccount:
  # Specifies whether a service account should be created and used
  create: false
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use. (default .Release.Name + "-default")
  name:

podSecurityContext:
  # intershop user - defined by icm-base-docker image
  runAsUser: 150
  runAsGroup: 150
  fsGroup: 150
  runAsNonRoot: true
  fsGroupChangePolicy: "OnRootMismatch"

testConnection:
  protocol: http
  port: 7743
  url: /servlet/ConfigurationServlet
  serviceSuffix:

resources:
  limits:
    cpu: 1000m
    memory: 3Gi
  requests:
    cpu: 1000m
    memory: 3Gi

# configure an external database for ICM
# in case value "mssql.enabled" is true - this section will be ignored
database:
  # type: "mssql" or "oracle"
  type: "mssql"
  # or for oracle "jdbc:oracle:thin:@<ipaddress or hostname>:1521:intershop"
  jdbcURL: "jdbc:sqlserver://<ipaddress or hostname>:1433;databaseName=intershop"
  jdbcUser: "intershop"
  jdbcPassword: "intershop"

# environment variables to be propagated to the icm-as-container
environment:
  CARTRIDGE_LIST: "ft_icm_as"

persistence:
  sites:
    size: 1Gi
    # type cluster | nfs | azurefiles | existingClaim | local
    type: local
    existingClaim: <claim name>
    cluster:
      storageClass:
        create: false
        # if create == false an exiting class could be set
        # if empty value is set the default storage class is used
        existingClass: ""
        # skuName: Standard_LRS
        # mountOptions:
        # - uid=150
        # - gid=150
        # - dir_mode=0777
        # - file_mode=0777
        # - mfsymlinks
        # - cache=strict
        # - actimeo=30
    azurefiles:
      shareName: icm-as-share
      secretName: icm-as-share-secret
    nfs:
      server: <ipaddress or hostname>
      path: <server folder>
    local:
      path: <local folder>
  jgroups:
    size: 1Gi
    # type emptyDir | existingClaim | cluster | local | azurefiles
    type: emptyDir
    existingClaim: <claim name>
    cluster:
      storageClass:
        create: false
        # if create == false an exiting class could be set
        # if empty value is set the default storage class is used
        existingClass: ""
    azurefiles:
      shareName: icm-as-jgroups
      secretName: icm-as-jgroups-secret
  customdata:
    enabled: false
    existingClaim: icm-as-cluster-customData-pvc
    mountPoint: /data

# Probes, all values are optional, below are the defaults
probes:
  startup: {}
  #    failureThreshold: 6
  #    initialDelaySeconds: 60
  #    periodSeconds: 10
  liveness: {}
  #    failureThreshold: 3
  #    initialDelaySeconds: 0
  #    periodSeconds: 10
  readiness: {}
#    failureThreshold: 3
#    initialDelaySeconds: 0
#    periodSeconds: 5

# Duration in seconds pod needs to terminate gracefully, value is optional, below is the default
# terminationGracePeriodSeconds: 30

# Enable Microsoft SQL Server for development and testing purposes.
# ICM will use jdbc:sqlserver://<release>-mssql:1433;database=<msslq.name>;
# see values of persistence.mssql-data and persistence.mssql-backup
mssql:
  enabled: false
  # recreate database on restart
  recreation: false
  resources:
    limits:
      cpu: 1000m
      memory: 2Gi
    requests:
      cpu: 1000m
      memory: 2Gi
  image:
    repository: "intershophub/mssql-intershop:2019-latest"
  # needs to be explicitally switched at deployment to "Y"
  acceptEula: "N"
  saPassword: "1nstershop5A"
  databaseName: "icmdb"
  user: "icmdbuser"
  password: "icmdbpassword"
  persistence:
    data:
      size: 5Gi
      # type cluster | nfs | azurefiles | existingClaim | local
      type: local
      existingClaim: <claim name>
      cluster:
        storageClass:
          create: false
          # if create == false an exiting class could be set
          # if empty value is set the default storage class is used
          existingClass: ""
          # skuName: Standard_LRS
          # additionalMountOptions:
          # - uid=150
          # - gid=150
          # - dir_mode=0777
          # - file_mode=0777
          # - mfsymlinks
          # - cache=strict
          # - actimeo=30
      azurefiles:
        shareName: <icm-as-mssql-data-share>
        secretName: <icm-as-mssql-secret>
      local:
        path: <local mssql data folder>
    backup:
      size: 5Gi
      # type cluster | nfs | azurefiles | existingClaim | local
      type: local
      existingClaim: <claim name>
      cluster:
        storageClass:
          create: false
          # if create == false an exiting class could be set
          # if empty value is set the default storage class is used
          existingClass: ""
          # skuName: Standard_LRS
          # additionalMountOptions:
          # - uid=150
          # - gid=150
          # - dir_mode=0777
          # - file_mode=0777
          # - mfsymlinks
          # - cache=strict
          # - actimeo=30
      azurefiles:
        shareName: <icm-as-mssql-backup-share>
        secretName: <icm-as-mssql-secret>
      local:
        path: <local mssql backup folder>

# allows it to copy the sites dir which is needed for our test execution
copySitesDir:
  enabled: false
  # fromDir: sites folder
  # resultDir: result folder where a sites.txt is generated to
  # chmodUser: user
  # chmodGroup: group

# configure an ingress here only if you don't use icm-web !
ingress:
  enabled: false
  className: null
  annotations:
    {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  # Paths are treated as list of prefixes. Any URL matching one of the prefixes will
  # be forwared to ICM.
  hosts:
    - host: <dns-name-of-service>
      paths:
        - path: /
          pathType: Prefix
  tls: []
  #  - secretName: chart-example-tls
  #    hosts:
  #      - chart-example.local

webLayer:
  enabled: false
  redis:
    enabled: false
    # Redisson client yaml config
    config: null

sslCertificateRetrieval:
  enabled: false
  supportV1: false
  # secretName: <explicit-ssl-secret-name>
  keyvault:
    tenantId: <tenant-ID-of-the-KeyVault>
    subscriptionId: <subscription-ID-of-the-KeyVault>
    resourceGroup: <resource-group-of-the-KeyVault>
    keyvaultName: <name-of-the-KeyVault>
    certificateName: <name-of-the-certificate>

# Configure configuration of the job-server.
# The job-server template inherits most properties from the configuration of the application-server.
# In order to override these properties add them in the job section, e.g. add a 'resources' section to
# configure different cpu or memory limits.
job:
  # if enabled=true the job controller must be deployed at cluster separatelly. see icm-job chart.
  enabled: false

  # If true, job-server-support will be available but no jobs will be created
  # suspend: false

  # Sets the polling interval of the job-scheduler in seconds, defaults to 30s
  # pollInterval: value_in_seconds

  # Sets the limit of failed jobs in the history. If the limit gets reached
  # eldest jobs will be deleted. Defaults to unlimited
  failedJobsHistoryLimit: 1

  # Sets the limit of successful jobs in the history. If the limit gets reached
  # eldest jobs will be deleted. Defaults to unlimited
  successfulJobsHistoryLimit: 3

  # If true the schedule-time-computer will be called with server name 'jobserver' and group == 'JOB'
  nameSpecific: false

  # Custom job-server name. Defaults to 'jobserver'
  # serverName: <CustomJobServerName>

# Configuration for a replication/staging scenario
replication:
  # enables/disables the replication support: whether or not this icm-as is part of a replication system
  enabled: false

  # defines the type of this replication system (source | target)
  role: <source|target>

  # if role=source the following properties are mandatory (otherwise they are ignored)
  # the external URL of the webServer/proxy/ingress e.g. https://icm-web-live-wa:443
  targetSystemUrl: <externalUrl>

  # the name of the (source) database to be used at the target-system to read data from e.g. intershop_edit
  sourceDatabaseName: <databaseName>

# Configuration of messaging via jgroups
jgroups:

  # the discovery protocol to use
  # supported values are file_ping or kube_ping. Defaults to file_ping, but kube_ping | azure_ping is recommended
  # file_ping (default) requires a mounted file system
  # kube_ping (recommended) please set serviceAccount.create to create service account if not exists to allow icm to talk with k8s api server
  # azure_ping (playground) mounts azure storage directly
  # dns_ping (playground) declared dns query
  discovery: file_ping

  # extra attributes to be added at the ping-section in xml,
  # e.g. "readTimeout=\"1000\" operationAttempts=\"5\""
  # discoveryExtraAttributes: <extra-attributes>

  # the DNS-query. Used with discovery type dns_ping
  dnsQuery: <dnsQuery>

  # label for multiple clusters in a release (default: .Release.Name)
  clusterLabel:
  # adaption of ports in case a different range is needed
  portRange:
