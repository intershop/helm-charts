= Documentation about what can be configured using the `values.yaml`-file
//include::definitions.include[]
// GitHub issue: https://github.com/github/markup/issues/1095
:icons: font
:experimental:

ifdef::backend-html5[]
++++
<style>
.mand {
  color: #e00000;
}
.opt {
  color: #b0adac;
}
.cond {
  color: #FFDC00;
}
.tag-audience {
  font-style: italic;
}
.tag-audience::before {
  content: "@Target Audience: ";
}
.tag-since {
  font-style: italic;
}
.tag-since::before {
  content: "@Since: ";
}

</style>
++++
endif::[]

:mandatory: icon:check[role="mand"]
:optional: icon:times[role="opt"]
:conditional: icon:question[role="cond"]

== Target audience

This document is intended for users of the Intershop Commerce Management Application Server (icm-as) Helm Chart who want to understand how to configure the chart using the `values.yaml` file. This explicitly includes developers, system administrators, and DevOps engineers who are responsible for deploying and managing the Intershop Commerce Management Application Server in a Kubernetes environment.

If a part of this document only targets a specific audience, it is explicitly marked as such.

== Sections overview

The following table gives a short overview about the different sections (sorted alphabetically):

[cols="1,3",options="header"]
|===
|Section |Topic
|<<_noSection,+<none>+>>|attributes without any section
|<<_copySitesDir,copySitesDir>>|copy sites directory
|<<_customizations,customizations>>|customizations to be deployed
|<<_database,database>>|database configuration
|dnsConfig|dns configuration
|dockerSecret|deployment of a docker registry secret
|environment|environment variables
|image|icm-as image configuration
|imagePullSecrets|image pull secrets
|ingress|ingress configuration
|infrastructureMonitoring|infrastructure monitoring configuration
|job|job server configuration
|jgroups|jgroups configuration
|jvm|icm-as jvm configuration
|mssql|deployment of an MSSQL database inside a pod
|newrelic|newrelic configuration
|nodeSelector|agent pool assignment
|operationalContext|operational context configuration
|persistence|persistence / volumes configuration
|podBindings|pod bindings
|podSecurityContext|pod security context
|probes|probes (startup, liveness, readiness) configuration
|replication|replication/staging configuration
|resources|resources / limits configuration
|secrets|secrets to be made available as environment variables
|<<secretMounts,secretMounts>>|secrets to be mounted as files / environment variables
|serviceAccount|service account to be deployed
|sslCertificateRetrieval|ssl certificate retrieval
|testConnection|test connection configuration
|tolerations|pod tolerations configuration
|webLayer|web layer (webadapter-replacement) configuration
|===

[#_noSection]
== Attributes without any section

=== Description

[cols="1,3,1,1,1",options="header"]
|===
|Attribute |Description |Type |Mandatory|Default Value
|<<_example_replicaCount,replicaCount>>|number of icm-as pods to be deployed|int|{optional}|`1`
|<<_example_updateStrategy,updateStrategy>>|define the https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#strategy[update strategy]|enum {`Recreate`, `RollingUpdate`}|{optional}|`RollingUpdate`
|<<_example_nameOverride,nameOverride>>|override the name used for label `app.kubernetes.io/name` which normally is calculated from chart name|string|{optional}|_<empty string>_
|<<_example_nameOverride,fullnameOverride>>|override the names/prefix of the several deployed resources which normally is calculated from chart and release name|string|{optional}|_<empty string>_
|<<_example_nodeSelector,nodeSelector>>|https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector[node selector configuration]|yaml object|{optional}|`{}`
|<<_example_deploymentAnnotations,deploymentAnnotations>>|https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/[annotations] applied to the `icm-as` https://kubernetes.io/docs/concepts/workloads/controllers/deployment/[deployment]|yaml object|{optional}|`{}`
|<<_example_deploymentLabels,deploymentLabels>>|https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/[labels] applied to the `icm-as` https://kubernetes.io/docs/concepts/workloads/controllers/deployment/[deployment]|yaml object|{optional}|`{}`
|<<_example_podAnnotations_podLabels,podAnnotations>>|https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/[annotations] applied to the `icm-as` and the 'jobServer' https://kubernetes.io/docs/concepts/workloads/pods/[pods]|yaml object|{optional}|`{}`
|<<_example_podAnnotations_podLabels,podLabels>>|https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/[labels] applied to the `icm-as` and the 'jobServer' https://kubernetes.io/docs/concepts/workloads/pods/[pods]|yaml object|{optional}|`{}`
|===

=== Examples

[NOTE]
====
The following examples use `my-icm-as` as the release name.
====

[#_example_replicaCount]
==== replicaCount
Configuring `replicaCount` like this:
[source,yaml]
----
replicaCount: 4
----
will result in 4 pods being deployed for the `icm-as` application server. With a deployment looking like:
[source,yaml]
----
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-icm-as
  labels:
    ...
    app: my-icm-as
spec:
  replicas: 4
----

[#_example_updateStrategy]
==== updateStrategy
Configuring `updateStrategy` like this:
[source,yaml]
----
updateStrategy: Recreate
----
will result in the `icm-as` deployment being updated using the https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#recreate-update-strategy[Recreate update strategy]. This means that all pods of the `icm-as` application server will be stopped and then started again. The deployment will look like this:

[source,yaml]
----
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-icm-as
  ...
spec:
  ...
  strategy:
    type: Recreate
    rollingUpdate:
      maxUnavailable: 0
      maxSurge: 1
----

[#_example_nameOverride]
==== nameOverride and fullnameOverride
Without configuring `nameOverride` and `fullnameOverride` all relevant names are generated from the release and chart name. So the 'icm-as-appserver' deployment looks like this:

[source,yaml]
----
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-icm-as
  labels:
    app.kubernetes.io/name: icm-as
    app.kubernetes.io/instance: my-icm-as
    app: my-icm-as
----

`nameOverride` can now be used to customize parts of this:
[source,yaml]
----
nameOverride: my-custom-icm-as
----
So the deployment will look like:
[source,yaml]
----
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-icm-as-my-custom-icm-as
  labels:
    app.kubernetes.io/name: my-custom-icm-as
    app.kubernetes.io/instance: my-icm-as
    app: my-icm-as-my-custom-icm-as
----

Other resources like the `icm-as` https://kubernetes.io/docs/concepts/services-networking/service/[service] will also use this name:
[source,yaml]
----
apiVersion: v1
kind: Service
metadata:
  name: my-icm-as-my-custom-icm-as
  labels:
    app: my-icm-as-my-custom-icm-as
----

`fullnameOverride` can be used to get full control over the names:
[source,yaml]
----
nameOverride: my-custom-icm-as
fullnameOverride: your-custom-icm-as
----
So the deployment will look like:
[source,yaml]
----
apiVersion: apps/v1
kind: Deployment
metadata:
  name: your-custom-icm-as
  labels:
    app.kubernetes.io/name: my-custom-icm-as
    app.kubernetes.io/instance: my-icm-as
    app: your-custom-icm-as
----

Other resources like the `icm-as` https://kubernetes.io/docs/concepts/services-networking/service/[service] will also use this fullname:
[source,yaml]
----
apiVersion: v1
kind: Service
metadata:
  name: your-custom-icm-as
  labels:
    app: your-custom-icm-as
----

[#_example_nodeSelector]
==== nodeSelector
[.tag-audience]#DevOps, Ops#

Configuring `nodeSelector` like this:
[source,yaml]
----
nodeSelector:
  label0: value0
  ...
  labeln: valuen
----
will result in the `icm-as` pods being scheduled on nodes that have the all the configured labels. The deployment will look like this:

[source,yaml]
----
apiVersion: apps/v1
kind: Deployment
...
spec:
  ...
  template:
    ...
    spec:
      nodeSelector:
        label0: value0
        ...
        labeln: valuen
----

[#_example_deploymentAnnotations]
==== deploymentAnnotations

Configuring `deploymentAnnotations` like this:
[source,yaml]
----
deploymentAnnotations:
  annotation0: value0
  ...
  annotationn: valuen
----
will result in the `icm-as` deployment annotated with the configured annotations. The deployment will look like this:

[source,yaml]
----
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-icm-as
  annotations:
    annotation0: value0
    ...
    annotationn: valuen
----

[#_example_deploymentLabels]
==== deploymentLabels

Configuring `deploymentLabels` like this:
[source,yaml]
----
deploymentLabels:
  label0: value0
  ...
  labeln: valuen
----
will result in the `icm-as` deployment labeled with the configured labels. The deployment will look like this:

[source,yaml]
----
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-icm-as
  labels:
    ...
    annotation0: value0
    ...
    annotationn: valuen
----

[#_example_podAnnotations_podLabels]
==== podAnnotations and podLabels

Configuring `podAnnotations` and `podLabels` basically does the same as `deploymentAnnotations` and `deploymentLabels` but instead annotating and labeling the deployment it will influence the annotations and labels of the `icm-as` and `jobserver` pods:
[source,yaml]
----
podAnnotations:
  annotation0: value0
  ...
  annotationn: valuen
deploymentLabels:
  label0: value0
  ...
  labeln: valuen
----

The `icm-as` deployment will look like this:

[source,yaml]
----
apiVersion: apps/v1
kind: Deployment
...
spec:
  ...
  template:
    metadata:
      annotations:
        ...
        annotation0: value0
        annotationn: valuen
      labels:
        ...
        label0: value0
        labeln: valuen
----

The `jobserver` resource will look like this:

[source,yaml]
----
apiVersion: batch.core.intershop.de/v1
kind: ICMJob
metadata:
  name: my-icm-as-job
  annotations:
    ...
    annotation0: value0
    annotationn: valuen
  labels:
    ...
    label0: value0
    labeln: valuen
----

[NOTE]
====
The annotations and labels inside of this resource will be processed by the job server operator that then deploys Kubernetes jobs that use pods containing the configured annotations and labels.
====

[#_copySitesDir]
== copySitesDir

[.tag-audience]#Developer, Test, DevOps#

=== Description

Allows to have files copied from a directory into the sites directory/volume of the `icm-as` container. This is
done by an https://kubernetes.io/docs/concepts/workloads/pods/init-containers/[init container] using the `icm-as` image that runs before the `icm-as` container starts.
The `copySitesDir` section contains the following attributes:

[cols="1,3,1,1,1",options="header"]
|===
|Attribute |Description |Type |Mandatory|Default Value
|enabled|enable/disable this feature|boolean|{optional}|`false`
|fromDir|source folder of the files/folder to be copied|absolute path|{mandatory}|-
|resultDir|folder for a `sites.txt` containing all the files inside of the `sites` volume|absolute path|{mandatory}|-
|chmodUser|user name/uid to be applied to all the files inside of the sites volume|user name/uid|{mandatory}|-
|chmodGroup|group name/gid to be applied to all the files inside of the sites volume|group name/gid|{mandatory}|-
|===

=== Example

[source,yaml]
----
copySitesDir:
  enabled: true
  fromDir: /some/custom/sites/files
  resultDir: /some/custom/sites
  chmodUser: intershop
  chmodGroup: intershop
----
This example will copy all files and folders from `/some/custom/sites/files` into the sites volume of the `icm-as` container and create a file `/some/custom/sites/sites.txt` containing all the files inside the sites volume. All files will be owned by `intershop:intershop`.

[#_customizations]
== customizations

=== Description

Defines the customizations to be deployed into the `icm-as` container. The customizations are defined as a yaml object containing attributes that define the customizations. The attribute's name defines a symbolic name of the customization to be deployed (). The following table lists the attributes of such a customization-object:

[cols="1,3,1,1,1",options="header"]
|===
|Attribute |Description |Type |Mandatory |Default Value
|repository|https://kubernetes.io/docs/concepts/containers/images/#image-names[image] to be used|image reference|{mandatory}|-
|pullPolicy|https://kubernetes.io/docs/concepts/containers/images/#image-pull-policy[image pull policy]|enum {`IfNotPresent`, `Always`, `Never`}|{optional}|`IfNotPresent`
|===

=== Example

[source,yaml]
----
customizations:
  headless: <1>
    repository: intershophub/icm-as-customization-headless:3.0.0
  solr: <2>
    repository: intershophub/icm-as-customization-f_solrcloud:6.0.0
  my-customization: <3>
    repository: my-repo/icm-as-customization-my_customization:1.0.0
    pullPolicy: Always
----
This example deploys three customizations into the `icm-as` container:

<1> `headless` using the image `intershophub/icm-as-customization-headless:3.0.0`
<2> `solr` using the image `intershophub/icm-as-customization-f_solrcloud:6.0.0`
<3> `my-customization` using the image `my-repo/icm-as-customization-my_customization:1.0.0` with pull policy `Always`

[#_database]
== database

=== Description

Configures the database connection to be used by the `icm-as` appserver. The following attributes are available:

[cols="1,3,1,1,1",options="header"]
|===
|Attribute |Description |Type |Mandatory |Default Value
|type|the type/vendor of the database|enum {`mssql`, `oracle`}|{optional}|`mssql`
|jdbcURL|the JDBC url pointing to the database|JDBC URL|{mandatory}|-
|jdbcUser|the database user|string|{mandatory}|-
|jdbcPassword|the database password|string|{conditional} mandatory if `jdbcPasswordSecretKeyRef` is not set |-
|jdbcPasswordSecretKeyRef|a secret key reference pointing to a secret containing the database password. *Takes precedence over `jdbcPassword`.* |<<_secretKeyRef,SecretKeyRef>>|{conditional} mandatory if `jdbcPassword` is not set |-
|===

[#_secretKeyRef]
==== Type `SecretKeyRef``

Type `SecretKeyRef` is a reference to a Kubernetes secret that contains the following attributes:

[cols="1,3,1,1,1",options="header"]
|===
|Attribute |Description |Type |Mandatory |Default Value
|name|name of the secret|string|{mandatory}|-
|key|key inside the secret pointing to the referenced secret data|string|{mandatory}|-
|===

=== Example

[source,yaml]
----
database:
  type: "mssql"
  jdbcURL: "jdbc:sqlserver://host.privatelink.database.windows.net:1433;database=icm-as;"
  jdbcUser: "icm-as"
  jdbcPasswordSecretKeyRef:
    name: icm-database
    key: password
----
This example configures the `icm-as` appserver to use a Microsoft SQL database:

* JDBC URL: `jdbc:sqlserver://host.privatelink.database.windows.net:1433;database=icm-as;`
* Database user: `icm-as`
* Database password: taken from the secret `icm-database`

[#_secretmounts]
== secretMounts

[.tag-since]#2.9.0#

=== Description

Allows the content of Kubernetes secrets to be mounted as files or made available as environment variables to the icm-as-server container.
The `secretMounts` section is a list of objects containing the following attributes:

[cols="1,3,1,1,1",options="header"]
|===
|Attribute |Description |Type |Mandatory |Default Value
|secretName|the name of the secret|string|{mandatory}|-
|type|the type of the secret|enum {`secret`, `certificate`}|{optional}|`secret`
|key|the data field inside the secret|string|{conditional} optional if `type=certificate`|`tls.crt` if `type=certificate`
|targetFile|path relative to `/secrets` if `type=secret` resp. `/certificates` if `type=certificate`|path|{optional}|-
|targetEnv|name of the environment variable to get made available|string|{optional}|-
|===

[WARNING]
====
If neither `targetFile` nor `targetEnv` is set, the `secretMounts`-entry will have no effect at all.
====

[NOTE]
====
`*.crt`-files mounted into `/certificates` are imported into the truststore of the `icm-as-server`-container's JVM. So they are available to validate SSL/TLS connections to other servers that use this certificate.
====

=== Example

[source,yaml]
----
secretMounts:
  - secretName: my-secret <1>
    type: secret
    targetFile: my-secret.txt
  - secretName: my-certificate <2>
    type: certificate
    key: tls.crt
    targetFile: my-certificate-file.crt
  - secretName: my-certificate <3>
    type: certificate
    key: tls.key
    targetFile: my-certificate-file.key
  - secretName: my-secret2 <4>
    type: secret
    targetEnv: MY_SECRET2
    targetFile: my-secret2.txt
----

The configuration above mounts the 3 secrets `my-secret`, `my-certificate` and `my-secret-env`:

<1> `my-secret` is mounted as file `/secrets/my-secret.txt`
<2> the certificate part of `my-certificate` is mounted as file `/certificates/my-certificate-file.crt`
<3> the private key part of `my-certificate` is mounted as file `/certificates/my-certificate-file.key`
<4> `my-secret2` is made available as environment variable `MY_SECRET2` and mounted as file `/secrets/my-secret2.txt`

Minimal variation of the above example (omitting optional attributes):

[source,yaml]
----
secretMounts:
  - secretName: my-secret
    targetFile: my-secret.txt
  - secretName: my-certificate
    type: certificate
    targetFile: my-certificate-file.crt
  - secretName: my-certificate
    type: certificate
    key: tls.key
    targetFile: my-certificate-file.key
  - secretName: my-secret2
    targetEnv: MY_SECRET2
    targetFile: my-secret2.txt
----

[NOTE]
====
See https://support.intershop.com/kb/index.php/Display/X31381[Guide - Secret Store Process] for details on how to make secrets and certificates from an Azure KeyVault available in K8s secrets.
====
